#include <compile/TemplateType.h>
#include <compile/Context.h>
#include <compile/ast/CompileHandler.h>
#include <compile/CompiledFunction.h>
#include <compile/TypeSpecializer.h>
#include <compile/Compiler.h>
#include <codegen/interfaces/IBackend.h>
#include <bind/util/meta.hpp>
#include <bind/Function.h>
#include <bind/interfaces/ITypeBuilder.h>
#include <utils/Array.hpp>
#include <utils/interfaces/IWithUserData.hpp>

namespace compile {
    TemplateType::TemplateType(const String& name, u32 typeArgumentCount, bind::Namespace*ns)
        : bind::DataType(name, bind::meta<void>(), ns), m_typeArgumentCount(typeArgumentCount),
        m_postProcessMask(0xFFFFFFFF), m_specializationData(nullptr), m_specializer(nullptr)
    {
        tsn_type_userdata& data = getUserData<tsn_type_userdata>();
        data.flags.indicator_bit = 1;
        data.flags.is_host_template = 1;
    }

    TemplateType::~TemplateType() {
    }

    u32 TemplateType::getTypeArgumentCount() const {
        return m_typeArgumentCount;
    }
    
    bind::DataType* TemplateType::specialize(Context* ctx, const Array<bind::DataType*>& typeArgs) {
        bind::DataType* result = nullptr;

        TemplateType::SpecializationData sp;
        sp.compilationContext = ctx;

        TypeSpecializer ts(this, ctx, sp.typeArguments);
        sp.specializedType = nullptr;
        
        for (u32 i = 0;i < typeArgs.size();i++) {
            sp.typeArguments.emplace(ctx, typeArgs[i], nullptr);
        }

        setMomentarySpecializer(&ts);
        setMomentarySpecializationData(&sp);

        // need to know all the symbol IDs that existed /before/ template type
        // method signatures are potentially generated so we can know later which
        // ones need to be removed if specialization fails for some reason
        std::unordered_set<bind::symbol_id> previousTypeSymbols;
        {
            std::shared_lock l(bind::Registry::ReadLock());
            auto types = bind::Registry::Types();
            for (bind::DataType* t : types) {
                previousTypeSymbols.insert(t->getSymbolId());
            }
        }

        bool didError = false;
        Array<bind::FunctionType*> generatedSignatures;

        try {
            bool setupPassed = onSpecialization(&ts);

            for (auto m : ts.m_methods) {
                if (previousTypeSymbols.count(m.signature->getSymbolId()) == 0) {
                    // this signature was generated by the call to onSpecialization
                    generatedSignatures.push(m.signature);
                }
            }

            if (!setupPassed) {
                didError = true;
                ctx->logError("Could not specialize type '%s' with the provided arguments", getName().c_str());
            } else {
                sp.specializedType = ts.claimType();

                if (!doSpecialization()) {
                    didError = true;
                    ctx->logError("Could not specialize type '%s' with the provided arguments", getName().c_str());
                } else {
                    result = sp.specializedType;
                    ctx->onTypeGenerated(result);

                    for (u32 i = 0;i < generatedSignatures.size();i++) {
                        ctx->onTypeGenerated(generatedSignatures[i]);
                    }
                }
            }
        } catch (const Exception& e) {
            didError = true;
            ctx->logError(
                "Encountered exception while specializing type '%s': %s",
                getName().c_str(),
                e.what()
            );

            if (generatedSignatures.size() == 0) {
                // possibly encountered exception in onSpecialization, these still need to be managed
                for (auto m : ts.m_methods) {
                    if (previousTypeSymbols.count(m.signature->getSymbolId()) == 0) {
                        // this signature was generated by the call to onSpecialization
                        generatedSignatures.push(m.signature);
                    }
                }
            }
        }

        cleanupMomentarySpecializationInfo();

        if (didError) {
            if (sp.specializedType) {
                bind::Registry::Remove(sp.specializedType);
                delete sp.specializedType;
                sp.specializedType = nullptr;
            }
            
            for (u32 i = 0;i < generatedSignatures.size();i++) {
                bind::Registry::Remove(generatedSignatures[i]);
                delete generatedSignatures[i];
            }

            result = nullptr;
        }
        
        return result;
    }
    
    bind::DataType* TemplateType::specialize(Context* ctx, CompileHandler* ch, const Array<parse::Node*>& typeArgs) {
        bind::DataType* result = nullptr;
        
        TemplateType::SpecializationData sp;
        sp.compilationContext = ctx;

        TypeSpecializer ts(this, ctx, sp.typeArguments);
        sp.specializedType = nullptr;
        
        for (u32 i = 0;i < typeArgs.size();i++) {
            typeArgs[i]->acceptVisitor(ch);
            bind::DataType* tp = ch->popLastType();
            sp.typeArguments.emplace(ctx, tp, typeArgs[i]);
        }

        setMomentarySpecializer(&ts);
        setMomentarySpecializationData(&sp);

        // need to know all the symbol IDs that existed /before/ template type
        // method signatures are potentially generated so we can know later which
        // ones need to be removed if specialization fails for some reason
        std::unordered_set<bind::symbol_id> previousTypeSymbols;
        {
            std::shared_lock l(bind::Registry::ReadLock());
            auto types = bind::Registry::Types();
            for (bind::DataType* t : types) {
                previousTypeSymbols.insert(t->getSymbolId());
            }
        }

        bool didError = false;
        Array<bind::FunctionType*> generatedSignatures;

        try {
            bool setupPassed = onSpecialization(&ts);

            for (auto m : ts.m_methods) {
                if (previousTypeSymbols.count(m.signature->getSymbolId()) == 0) {
                    // this signature was generated by the call to onSpecialization
                    generatedSignatures.push(m.signature);
                }
            }

            if (!setupPassed) {
                didError = true;
                ctx->logError("Could not specialize type '%s' with the provided arguments", getName().c_str());
            } else {
                sp.specializedType = ts.claimType();

                if (!doSpecialization()) {
                    didError = true;
                    ctx->logError("Could not specialize type '%s' with the provided arguments", getName().c_str());
                } else {
                    result = sp.specializedType;
                    ctx->onTypeGenerated(result);

                    for (u32 i = 0;i < generatedSignatures.size();i++) {
                        ctx->onTypeGenerated(generatedSignatures[i]);
                    }
                }
            }
        } catch (const Exception& e) {
            didError = true;
            ctx->logError(
                "Encountered exception while specializing type '%s': %s",
                getName().c_str(),
                e.what()
            );

            if (generatedSignatures.size() == 0) {
                // possibly encountered exception in onSpecialization, these still need to be managed
                for (auto m : ts.m_methods) {
                    if (previousTypeSymbols.count(m.signature->getSymbolId()) == 0) {
                        // this signature was generated by the call to onSpecialization
                        generatedSignatures.push(m.signature);
                    }
                }
            }
        }

        cleanupMomentarySpecializationInfo();

        if (didError) {
            if (sp.specializedType) {
                bind::Registry::Remove(sp.specializedType);
                delete sp.specializedType;
                sp.specializedType = nullptr;
            }
            
            for (u32 i = 0;i < generatedSignatures.size();i++) {
                bind::Registry::Remove(generatedSignatures[i]);
                delete generatedSignatures[i];
            }

            result = nullptr;
        }
        
        return result;
    }

    void TemplateType::setMomentarySpecializationData(SpecializationData* data) {
        m_specializationData = data;
    }

    void TemplateType::setMomentarySpecializer(TypeSpecializer* specializer) {
        m_specializer = specializer;
    }

    void TemplateType::cleanupMomentarySpecializationInfo() {
        m_specializationData = nullptr;
        m_specializer = nullptr;
    }

    bool TemplateType::doSpecialization() {
        m_specializationData->compilationContext->logDebug(
            "Specializing template type '%s': '%s'",
            getName().c_str(),
            m_specializationData->specializedType->getName().c_str()
        );

        bind::ITypeBuilder extend(m_specializationData->specializedType);
        bind::DataType* voidTp = bind::Registry::GetType<void>();

        for (u32 i = 0;i < m_specializer->m_methods.size();i++) {
            TypeSpecializer::MethodBuilder& m = m_specializer->m_methods[i];

            m_specializationData->compilationContext->logDebug(
                "Generating user defined method '%s::%s'",
                m_specializationData->specializedType->getName().c_str(),
                m.name.c_str()
            );

            bind::Function* fn = new bind::Function(
                m.name,
                m.signature,
                m_specializationData->specializedType->getOwnNamespace()
            );

            codegen::FunctionBuilder fb(fn);
            fb.enableValidation();

            bool didSucceed = true;

            try {
                (*this.*m.methodPtr)(&fb);
            } catch (const Exception& e) {
                m_specializationData->compilationContext->logError(
                    "User defined method generator for '%s::%s' failed validation with the following error",
                    m_specializationData->specializedType->getName().c_str(),
                    m.name.c_str()
                );
                m_specializationData->compilationContext->logInfo(e.what());

                didSucceed = false;
            }

            if (didSucceed) {
                try {
                    Compiler* c = m_specializationData->compilationContext->getCompiler();
                    if (!c->getBackend()->process(&fb, m_postProcessMask)) {
                        m_specializationData->compilationContext->logError(
                            "Compiler backend failed to process code for user defined method '%s::%s'",
                            m_specializationData->specializedType->getName().c_str(),
                            m.name.c_str()
                        );

                        didSucceed = false;
                    }
                } catch (const Exception& e) {
                    m_specializationData->compilationContext->logError(
                        "Compiler backend failed to process code for user defined method '%s::%s' with the following error",
                        m_specializationData->specializedType->getName().c_str(),
                        m.name.c_str()
                    );
                    m_specializationData->compilationContext->logInfo(e.what());

                    didSucceed = false;
                }
            }

            if (!didSucceed) {
                delete fn;
                return false;
            }

            bind::DataType::Property& prop = extend.addProperty(
                Pointer(fn),
                m.flags,
                fn->getSignature(),
                m.name
            );

            tsn_property_userdata& data = prop.getUserData<tsn_property_userdata>();
            data.flags.indicator_bit = 1;
            
            m_specializationData->compilationContext->onFunctionGenerated(fn);
        }

        return true;
    }
};